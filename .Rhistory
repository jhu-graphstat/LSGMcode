spectralDecomp = eigen(A)
ase = spectralDecomp$vectors[,1:d] %*% diag(sqrt(spectralDecomp$values[1:d]))
c1 = var(sqrt(n)*ase[tau ==1,])
c2 = var(sqrt(n)*ase[tau ==2,])
return(list(c1 = c1, c2 = c2))
}
getSpectralNormDifferenceFullFcn = function(delta, centers, rho, n, d){
theoC1 = getCovMat(centers[1,], rho, delta, centers)
theoC2 = getCovMat(centers[2,], rho, delta, centers)
simGraph = sampleSBMfromTrueLatentPosition(n, rho, centers)
empCov = getSpectralEstAndCov(simGraph$A, simGraph$tau, d)
dif1 = norm(empCov$c1-theoC1, "2")
dif2 = norm(empCov$c2-theoC2, "2")
return(cbind(dif1, dif2))
}
getSpectralNormDifferenceFullFcn = function(B, rho, n, d){
tmp = getCentersAndDelta(B, rho)
delta = tmp$delta
centers = tmp$centers
rm(tmp)
theoC1 = getCovMat(centers[1,], rho, delta, centers)
theoC2 = getCovMat(centers[2,], rho, delta, centers)
simGraph = sampleSBMfromTrueLatentPosition(n, rho, centers)
empCov = getSpectralEstAndCov(simGraph$A, simGraph$tau, d)
dif1 = norm(empCov$c1-theoC1, "2")
dif2 = norm(empCov$c2-theoC2, "2")
return(cbind(dif1, dif2))
}
getSpectralNormDifferenceFullFcn(B, rho, n, 2)
tmp = getCentersAndDelta(B, rho)
delta = tmp$delta
centers = tmp$centers
rm(tmp)
theoC1 = getCovMat(centers[1,], rho, delta, centers)
theoC2 = getCovMat(centers[2,], rho, delta, centers)
simGraph = sampleSBMfromTrueLatentPosition(n, rho, centers)
empCov = getSpectralEstAndCov(simGraph$A, simGraph$tau, d)
getSpectralNormDifferenceFullFcn = function(B, rho, n, d){
tmp = getCentersAndDelta(B, rho)
delta = tmp$delta
centers = tmp$centers
rm(tmp)
theoC1 = getCovMat(centers[1,], rho, delta, centers)
theoC2 = getCovMat(centers[2,], rho, delta, centers)
simGraph = sampleSBMfromTrueLatentPosition(n, rho, centers)
empCov = getSpectralEstAndCov(simGraph$adjacency, simGraph$tau, d)
dif1 = norm(empCov$c1-theoC1, "2")
dif2 = norm(empCov$c2-theoC2, "2")
return(cbind(dif1, dif2))
}
getSpectralNormDifferenceFullFcn(B, rho, n, 2)
n_vec = seq(500, 4000, by = 200)
difNormMat = matrix(NA, nrow = length(n_vec), ncol = 2)
B = matrix(c(0.42, 0.42, 0.42, 0.5), 2,2)
rho = c(0.6, 0.4)
n_vec = seq(500, 4000, by = 200)
difNormMat = matrix(NA, nrow = length(n_vec), ncol = 2)
for (i in 1: length(n_vec)){
n = n_vec[i]
difNormMat[i,] = getSpectralNormDifferenceFullFcn(B, rho, n, 2)
}
difNormMat
plot(difNormMat[,1])
plot(n_vec, difNormMat[,1])
B = matrix(c(0.7, 0.32, 0.32, 0.75), 2,2)
rho = c(0.4, 0.6)
n = 500
tmp = getCentersAndDelta(B, rho)
delta = tmp$delta
centers = tmp$centers
rm(tmp)
theoC1 = getCovMat(centers[1,], rho, delta, centers)
theoC2 = getCovMat(centers[2,], rho, delta, centers)
simGraph = sampleSBMfromTrueLatentPosition(n, rho, centers)
spectralDecomp = eigen(simGraph$adjacency)
ase = spectralDecomp$vectors[,1:2] %*% diag(sqrt(spectralDecomp$values[1:2]))
plot(ase, col = simGraph$tau + 1, pch = simGraph$tau, xlab = "ASE1", ylab = "ASE2")
n_vec = seq(500, 2000, by = 100)
difNormMat = matrix(NA, nrow = length(n_vec), ncol = 2)
length(n_vec)
for (i in 1: length(n_vec)){
n = n_vec[i]
difNormMat[i,] = getSpectralNormDifferenceFullFcn(B, rho, n, 2)
}
difNormMat
plot(difNormMat)
plot(n_vec, difNormMat[,1])
n_vec = seq(500, 4000, by = 100)
difNormMat = matrix(NA, nrow = length(n_vec), ncol = 2)
for (i in 1: length(n_vec)){
n = n_vec[i]
difNormMat[i,] = getSpectralNormDifferenceFullFcn(B, rho, n, 2)
}
plot(n_vec, difNormMat[,1])
plot(n_vec, difNormMat[,1], type = "l")
lo = loess(difNormMat[,1]~n_vec)
lines(predict(lo))
lines(predict(lo), col = 'red')
plot(predict(lo), col = 'red')
plot(predict(lo), type = 'l', col = 'red')
plot(n_vec, predict(lo), type = 'l', col = 'red')
difNormMat[,1]
plot(n_vec, difNormMat[,2], type = "l")
lo2 = loess(difNormMat[,2]~n_vec)
plot(n_vec, predict(lo), type = 'l', col = 'red')
plot(n_vec, predict(lo2), type = 'l', col = 'red')
difNormMat[,2]
plot(n_vec, difNormMat[,1]+difNormMat[,2])
plot(n_vec, difNormMat[,1]+difNormMat[,2], type = 'l')
B
delta
difNormMat[length(n_vec),]
difNormMat[1,]
centers = eigen(B)$vector %*% diag(sqrt(eigen(B)$values))
centers
delta
plot(centers)
plot(ase, col = tau)
plot(ase, col = simGraph$tau)
points(centers, cex = 4)
points(-centers, cex = 4)
plot(-ase, col = simGraph$tau)
points(centers, cex = 4)
centers
B
centers = eigen(B)$vector %*% diag(sqrt(eigen(B)$values))
x1 = centers[1,]
x2 = centers[2,]
delta = outer(x1,x1)*rho[1] + outer(x2, x2)*rho[2]
delta
centers
x1
plot(x1)
plot(cbind(x1, x2))
x2
x2 = centers[2,]
plot(cbind(x1, x2))
plot(centers)
plot(0.694, -0.467)
points(0.751, 0.4321)
plot(0.694, -0.467, ylim = c(-0.5, 0.5))
points(0.751, 0.4321)
tmp11 = outer(centers[1,], centers[1,])
tmpx1 = t(x) %*% centers[1,]
theoCov1 = getCovMat(centers[1,], rho, delta, centers)
theoCov1
theoCov2
theoCov2 = getCovMat(centers[2,], rho, delta, centers)
theoCov2
theoC1
n
theoC2 = getCovMat(centers[2,], rho, delta, centers)
theoC2
theoC1 = getCovMat(centers[1,], rho, delta, centers)
theoCov1
x1 = centers[1,]
x2 = centers[2,]
priorVec  = rbern(n, rho[2])
tau = priorVec + 1
trueLatentPosition = priorVec %*% t(x2) + (1 - priorVec) %*% t(x1)
P = trueLatentPosition %*% t(trueLatentPosition)
A = rg.sample(P)
dim(A)
table(tau)
rho
table(trueLatentPosition)
x1
x2
trueLatentPosition[1:4,]
spectralDecomp = eigen(A)
ase = spectralDecomp$vectors[,1:d] %*% diag(sqrt(spectralDecomp$values[1:d]))
d = 2
ase = spectralDecomp$vectors[,1:d] %*% diag(sqrt(spectralDecomp$values[1:d]))
plot(ase, col = tau + 1)
points(-centers, col = "blue", cex = 3)
centers
P[1:3,1:3]
eigen(B)
eigen(B)$vector %*% diag(sqrt(eigen(B)$values))
plot(-ase, col = tau)
points(centers, cex = 5)
B = c(0.42, 0.42, 0.42, 0.5)
B = matrix(B, 2,2)
centers = eigen(B)$vector %*% diag(sqrt(eigen(B)$values))
centers
x1 = centers[1,]
x2 = centers[2,]
delta = outer(x1,x1)*rho[1] + outer(x2, x2)*rho[2]
theoC1 = getCovMat(centers[1,], c(0.6, 0.4), delta, centers)
theoC2 = getCovMat(centers[2,], c(0.6, 0.4), delta, centers)
x1 = centers[1,]
x2 = centers[2,]
priorVec  = rbern(n, rho[2])
tau = priorVec + 1
trueLatentPosition = priorVec %*% t(x2) + (1 - priorVec) %*% t(x1)
P = trueLatentPosition %*% t(trueLatentPosition)
A = rg.sample(P)
spectralDecomp = eigen(A)
ase = spectralDecomp$vectors[,1:d] %*% diag(sqrt(spectralDecomp$values[1:d]))
plot(ase, col = tau+1)
points(-center)
points(-centers, cex = 4)
points(eigen(B)$vector, cex =3, col = "blue")
eigen(B)$vector
points(-eigen(B)$vector, cex =3, col = "blue")
c1 = var(sqrt(n)*ase[tau ==1,])
c2 = var(sqrt(n)*ase[tau ==2,])
dif1 = norm(c1-theoC1, "2")
dif2 = norm(c2-theoC2, "2")
dif1
dif2
B = matrix(c(0.7, 0.32, 0.32, 0.75), 2,2)
rho = c(0.4, 0.6)
n = 500
tmp = getCentersAndDelta(B, rho)
delta = tmp$delta
centers = tmp$centers
rm(tmp)
theoC1 = getCovMat(centers[1,], rho, delta, centers)
theoC2 = getCovMat(centers[2,], rho, delta, centers)
simGraph = sampleSBMfromTrueLatentPosition(n, rho, centers)
spectralDecomp = eigen(simGraph$adjacency)
ase = spectralDecomp$vectors[,1:2] %*% diag(sqrt(spectralDecomp$values[1:2]))
plot(ase, col = simGraph$tau + 1, pch = simGraph$tau, xlab = "ASE1", ylab = "ASE2")
points(-centers)
n_vec = seq(500, 4000, by = 100)
difNormMat = matrix(NA, nrow = length(n_vec), ncol = 2)
for (i in 1: length(n_vec)){
n = n_vec[i]
difNormMat[i,] = getSpectralNormDifferenceFullFcn(B, rho, n, 2)
}
plot(n_vec, difNormMat[,2])
plot(n_vec, difNormMat[,2], type = "l")
lo2 = loess(difNormMat[,2]~n_vec)
plot(n_vec, predict(lo2), type = 'l', col = 'red')
plot(n_vec, difNormMat[,1], type = "l")
lo = loess(difNormMat[,1]~n_vec)
plot(n_vec, predict(lo), type = 'l', col = 'red')
View(difNormMat)
dim(ase)
dim(difNormMat)
save(difNormMat, file = "~/Dropbox/Research/Robust_est/simulationExp/result/difSpectralNorm.RData" )
save(n_vec, difNormMat, file = "~/Dropbox/Research/Robust_est/simulationExp/result/difSpectralNorm.RData" )
n_vec[1:10]
n_vec[1:15]
plot(n_vec[1:16], difNormMat[1:16,2], type = "l")
lo2 = loess(difNormMat[,2]~n_vec)
plot(n_vec, predict(lo2), type = 'l', col = 'red')
lo2 = loess(difNormMat[1:16,2]~n_vec[1:16])
plot(n_vec[1:16], predict(lo2), type = 'l', col = 'red')
plot(n_vec[1:16], difNormMat[1:16,2], type = "l")
lo2 = loess(difNormMat~n_vec)
plot(n_vec[1:16], predict(lo2)[1:16], type = 'l', col = 'red')
lo = loess(difNormMat[,1]~n_vec)
plot(n_vec[1:16], predict(lo)[1:16], type = 'l', col = 'red')
lo2 = loess(difNormMat[,2]~n_vec)
plot(n_vec[1:16], predict(lo2)[1:16], type = 'l', col = 'red')
lo = loess(difNormMat[,1]~n_vec)
plot(n_vec[1:16], predict(lo)[1:16], type = 'l', col = 'red')
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red')
plot(n_vec[1:12], predict(lo2)[1:12], type = 'l', col = 'red')
lo2 = loess(difNormMat[,2]~n_vec)
plot(n_vec[1:12], predict(lo2)[1:12], type = 'l', col = 'red')
plot(n_vec, difNormMat[,1], type = "l")
plot(n_vec[1:16], difNormMat[1:16,2], type = "l")
lo2 = loess(difNormMat[,2]~n_vec)
plot(n_vec, predict(lo2), type = 'l', col = 'red')
plot(n_vec, predict(lo), type = 'l', col = 'red')
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red')
? norm
install.packages("tikzDevice")
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression(hat(X)))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression(Empirical Cov _{1}))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression(Empirical Cov[I]))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression(EmpiricalCov[I]))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = paste0("Empirical", expression(Cov[1]-), "Theoretical", expression(Cov[2]) )
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = paste0("Empirical", expression(Cov[1]-), "Theoretical", expression(Cov[2]) ))
paste0("Empirical", expression(Cov[1]-), "Theoretical", expression(Cov[2]))
paste0("Empirical", expression(Cov[1]), " - Theoretical", expression(Cov[2]))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = paste0("Empirical", expression(Cov[1]), " - Theoretical", expression(Cov[2])))
paste0("Empirical", expression(Cov_[1]), " - Theoretical", expression(Cov_[2]))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = paste0("Empirical", expression(Cov[1]), " - Theoretical", expression(Cov[2])))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = paste0("Empirical", expression("Cov"[1]), " - Theoretical", expression("Cov"[2])))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression("This is a subscript "[2])))
expression("This is a subscript "[2]
)
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression("This is a subscript"[2]))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression("Empirical Covariance"[2]))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = paste0(expression("Empirical Covariance"[1]), expression("Theoretical Covariance"[1])))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression("Empirical Covariance"[1]))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression("Spectral Norm of Empirical Covariance - Theoretical Covariance"[1]))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = expression("Spectral Norm C"[1] "-C"[2]))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', xlab = "Number of vertices",
ylab = "Spectral norm of EmpCov1 - TheoCov1")
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', lwd = 4, xlab = "Number of vertices",
ylab = "Spectral norm of EmpCov1 - TheoCov1")
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', lwd = 4, xlab = "Number of vertices",
ylab = "Spectral norm of (EmpCov1 - TheoCov1)")
plot(n_vec[1:12], predict(lo2)[1:12], type = 'l', col = 'red', lwd = 4, xlab = "Number of vertices",
ylab = "Spectral norm of (EmpCov2 - TheoCov2)")
png("~/Dropbox/Research/Robust_est/simulationExp/figs/exampleOfIdealCaseCov1Convergence.png")
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', lwd = 4, xlab = "Number of vertices",
ylab = "Spectral norm of (EmpCov1 - TheoCov1)")
dev.off()
png("~/Dropbox/Research/Robust_est/simulationExp/figs/exampleOfIdealCaseCov2Convergence.png")
plot(n_vec[1:12], predict(lo2)[1:12], type = 'l', col = 'red', lwd = 4, xlab = "Number of vertices",
ylab = "Spectral norm of (EmpCov2 - TheoCov2)")
dev.off()
par(mfrow=c(1,2))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', lwd = 4, xlab = "Number of vertices",
ylab = "Spectral norm of (EmpCov1 - TheoCov1)")
plot(n_vec[1:12], predict(lo2)[1:12], type = 'l', col = 'red', lwd = 4, xlab = "Number of vertices",
ylab = "Spectral norm of (EmpCov2 - TheoCov2)")
dev.off()
png("~/Dropbox/Research/Robust_est/simulationExp/figs/exampleOfIdealCaseCovConvergenceCombinedPlot.png")
par(mfrow=c(1,2))
plot(n_vec[1:12], predict(lo)[1:12], type = 'l', col = 'red', lwd = 4, xlab = "Number of vertices",
ylab = "Spectral norm of (EmpCov1 - TheoCov1)")
plot(n_vec[1:12], predict(lo2)[1:12], type = 'l', col = 'red', lwd = 4, xlab = "Number of vertices",
ylab = "Spectral norm of (EmpCov2 - TheoCov2)")
dev.off()
set.seed(88)
n
n = 500
trainSize = 2/3 * n
trainSize
trainSize = round(2/3 * n)
trainSize
I = sample(1:n, trainSize)
B = matrix(c(0.7, 0.32, 0.32, 0.75), 2,2)
rho = c(0.4, 0.6)
n = 500
tmp = getCentersAndDelta(B, rho)
delta = tmp$delta
centers = tmp$centers
rm(tmp)
simGraph = sampleSBMfromTrueLatentPosition(n, rho, centers)
spectralDecomp = eigen(simGraph$adjacency)
ase = spectralDecomp$vectors[,1:2] %*% diag(sqrt(spectralDecomp$values[1:2]))
g1 <- lda(simGraph$tau ~., ase, subset = (1:n)[-I])
g1 <- lda(simGraph$tau ~., data.frame(ase), subset = (1:n)[-I])
result <- predict(g1, data.frame(ase[I,]))
result
Y.pred <- result$posterior
Y.predClass <- result$class
Y.true <- simGraph$tau[I]
mean(Y.predClass == Y.true)
pred = prediction(Y.pred[, which(colnames(Y.pred) == 1)], Y.true)
require("ROCR")
install.packages("ROCR")
require("ROCR")
install.packages("gdata")
require("gdata")
require("ROCR")
install.packages("bitops")
require("bitops")
require("ROCR")
install.packages("caTools")
require("ROCR")
install.packages("ROCR")
require("ROCR")
pred = prediction(Y.pred[, which(colnames(Y.pred) == 1)], Y.true)
perf = performance(pred,  'tpr', 'fpr')
plot(perf, lwd = 2, box.lty=7, xlim = c(0,1), ylim = c(0,1), main = "ROC (Linear discriminant analysis)")
pred
pred = prediction(Y.pred[, which(colnames(Y.pred) == 2)], Y.true)
perf = performance(pred,  'tpr', 'fpr')
plot(perf, lwd = 2, box.lty=7, xlim = c(0,1), ylim = c(0,1), main = "ROC (Linear discriminant analysis)")
plot(ase)
g1 = lda(simGraph$tau ~., data.frame(ase), subset = (1:n)[-I])
summary(g1)
result = predict(g1, data.frame(ase[I,]))
result
Y.pred = result$posterior
Y.predClass = result$class
Y.true = simGraph$tau[I]
acc = mean(Y.predClass == Y.true)
Y.true
Y.predClass
mean(Y.predClass == Y.true)
perfAUC = performance(pred, 'auc')
perfAUC
g2 = qda(simGraph$tau ~., data.frame(ase), subset = (1:n)[-I])
result = predict(g1, data.frame(ase[I,]))
Y.pred = result$posterior
Y.predClass = result$class
Y.true = simGraph$tau[I]
acc = mean(Y.predClass == Y.true)
acc
require('lda')
demo(mmsb)
setwd("~/Dropbox/lsgm/scalability/")
corr3_projection = read.table("./runtime_corr3/projection_corr3.txt")
corr3_procrus = read.table("./runtime_corr3/procrusties_corr3.txt")
corr3_clust = read.table("./runtime_corr3/clustering_corr3.txt")
corr3_match = read.table("./runtime_corr3/matching_corr3.txt")
corr3_run_per_step = cbind(corr3_projection, corr3_procrus, corr3_clust, corr3_match)
ind = 1:nrow(corr3_clust)
extract_ind = ind[seq(1, length(ind), 4)]
corr3_run_per_step[extract_ind,]
colMeans(corr3_run_per_step[extract_ind,])
sd
sd(corr3_run_per_step[extract_ind,])
?sd
apply(corr3_run_per_step[extract_ind,], 2, st)
apply(corr3_run_per_step[extract_ind,], 2, sd)
i=2
ind[seq(i, length(ind)+i-1, 4)]
ind[seq(1, length(ind)+1-1, 4)]
ind[seq(3, length(ind)+3-1, 4)]
ind[seq(4, length(ind)+4-1, 4)]
for (i in 1:4){
ind = 1:nrow(corr3_clust)
extract_ind = ind[seq(i, length(ind)+i-1, 4)]
colMeans(corr3_run_per_step[extract_ind,])
apply(corr3_run_per_step[extract_ind,], 2, sd)
}
for (i in 1:4){
ind = 1:nrow(corr3_clust)
extract_ind = ind[seq(i, length(ind)+i-1, 4)]
print(colMeans(corr3_run_per_step[extract_ind,]))
print(apply(corr3_run_per_step[extract_ind,], 2, sd))
}
print(colMeans(corr3_run_per_step[extract_ind,]))
corr3_run_per_step = data.frame(cbind(corr3_projection, corr3_procrus, corr3_clust, corr3_match))
for (i in 1:4){
ind = 1:nrow(corr3_clust)
extract_ind = ind[seq(i, length(ind)+i-1, 4)]
print(colMeans(corr3_run_per_step[extract_ind,]))
print(apply(corr3_run_per_step[extract_ind,], 2, sd))
}
names(corr3_run_per_step)
corr3_run_per_step[1,]
rm(list = ls())
setwd("~/Dropbox/lsgm/scalability/")
corr3_projection = read.table("./runtime_corr3/projection_corr3.txt")
corr3_procrus = read.table("./runtime_corr3/procrusties_corr3.txt")
corr3_clust = read.table("./runtime_corr3/clustering_corr3.txt")
corr3_match = read.table("./runtime_corr3/matching_corr3.txt")
corr3_run_per_step = data.frame(cbind(corr3_projection, corr3_procrus, corr3_clust, corr3_match))
names(corr3_run_per_step) = c('embedding', 'procrusties', 'clustering', 'matching')
for (i in 1:4){
ind = 1:nrow(corr3_clust)
extract_ind = ind[seq(i, length(ind)+i-1, 4)]
print(colMeans(corr3_run_per_step[extract_ind,]))
print(apply(corr3_run_per_step[extract_ind,], 2, sd))
}
projection = read.table("./runtime_corr6/projection_corr6.txt")
procrus = read.table("./runtime_corr6/procrusties_corr6.txt")
clust = read.table("./runtime_corr6/clustering_corr6.txt")
match = read.table("./runtime_corr6/matching_corr6.txt")
run_per_step = data.frame(cbind(projection, procrus, clust, match))
names(run_per_step) = c('embedding', 'procrusties', 'clustering', 'matching')
for (i in 1:4){
ind = 1:nrow(clust)
extract_ind = ind[seq(i, length(ind)+i-1, 4)]
print(colMeans(run_per_step[extract_ind,]))
print(apply(run_per_step[extract_ind,], 2, sd))
}
projection = read.table("./runtime_corr9/projection_corr9.txt")
procrus = read.table("./runtime_corr9/procrusties_corr9.txt")
clust = read.table("./runtime_corr9/clustering_corr9.txt")
match = read.table("./runtime_corr9/matching_corr9.txt")
run_per_step = data.frame(cbind(projection, procrus, clust, match))
names(run_per_step) = c('Embedding', 'Procrusties', 'Clustering', 'Matching')
for (i in 1:4){
ind = 1:nrow(clust)
extract_ind = ind[seq(i, length(ind)+i-1, 4)]
print(colMeans(run_per_step[extract_ind,]))
print(apply(run_per_step[extract_ind,], 2, sd))
}
9.42/(9.42+0.53+.0010+0.1)
projection = read.table("./runtime_corr6/projection_corr6.txt")
procrus = read.table("./runtime_corr6/procrusties_corr6.txt")
clust = read.table("./runtime_corr6/clustering_corr6.txt")
match = read.table("./runtime_corr6/matching_corr6.txt")
run_per_step = data.frame(cbind(projection, procrus, clust, match))
names(run_per_step) = c('Embedding', 'Procrusties', 'Clustering', 'Matching')
for (i in 1:4){
ind = 1:nrow(clust)
extract_ind = ind[seq(i, length(ind)+i-1, 4)]
print(colMeans(run_per_step[extract_ind,]))
print(apply(run_per_step[extract_ind,], 2, sd))
}
projection = read.table("./runtime_corr3/projection_corr3.txt")
procrus = read.table("./runtime_corr3/procrusties_corr3.txt")
clust = read.table("./runtime_corr3/clustering_corr3.txt")
match = read.table("./runtime_corr3/matching_corr3.txt")
run_per_step = data.frame(cbind(projection, procrus, clust, match))
names(run_per_step) = c('Embedding', 'Procrusties', 'Clustering', 'Matching')
for (i in 1:4){
ind = 1:nrow(clust)
extract_ind = ind[seq(i, length(ind)+i-1, 4)]
print(colMeans(run_per_step[extract_ind,]))
print(apply(run_per_step[extract_ind,], 2, sd))
}
